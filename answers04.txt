1. Кратко опишите основные отличия `state` от `props`.
`props` представляет входные данные, которые передаются в компонент извне, а state хранит объекты, которые создаются в компоненте и полностью зависят от компонента.
Также в отличие от `props` значения в `state` можно изменять.
Значения из state должны использоваться при рендеринге. Если какой-то объект не используется в рендеринге компонента, то нет смысла сохранять его в state .

2. Какую ошибку я допустила в следующем коде и как её исправить:

    ```jsx
    handleChange = () => {
        const chechedArr = this.state.arr; // [1,2,3]
    		chechedArr.push(5); // [1,2,3,5]
        this.setState({
          arr: chechedArr,
        });
      };
    ```

Здесь изменяется существующий массив this.state.arr напрямую, не создавая новый массив. В React непосредственное изменение состояния, например, массива или объекта, может привести к нежелательным эффектам. Когда массив изменяют напрямую, React не распознает изменение и не вызывает повторный рендеринг компонента.
Чтобы исправить это, нужно создать новый массив на основе текущего состояния и добавить элемент в новый массив. Используем функцию setState, которая принимает колбэк, использующий предыдущее состояние, чтобы создать новый массив с добавленным элементом:

handleChange = () => {
  this.setState(prevState => {
    const checkedArr = [...prevState.arr, 5];
    return { arr: checkedArr }; 
  });
};

То есть сначала создаем копию текущего массива prevState.arr с помощью оператора расширения ..., а затем добавляем новый элемент 5 в конец созданного массива. Затем используем setState, чтобы обновить состояние компонента с новым массивом, что приведет к перерендерингу компонента с учетом нового состояния.

3. Можно ли повесить на один элемент несколько обработчиков событий?
Да, в React можно повесить несколько обработчиков событий на один элемент. Для этого обработчики событий следует передавать как список функций.
Example extends Component {
  handleClick = e => {
    const { firstHandler, secondHandler } = this.props;
    firstHandler(e);
    secondHander(e);
  };
  render() {
    return <button onClick={this.handleClick}>Click me</button>;
  }
}

4. Каким образом можно изменить `state`?
Для установки нового состояния в React предусмотрена функция setState . Именно её вызов приводит к тому, что компонент перерисуется. Происходит это не сразу, то есть setState работает асинхронно.
newState - новое состояние, которое нужно установить. Это может быть объектом, содержащим новые значения для свойств состояния, или функцией, которая принимает предыдущее состояние и возвращает новое.
callback (опционально) - функция, вызываемая после успешного обновления состояния и перерендеринга компонента.

5. Попробуйте предсказать, какие сообщения будут в консоли, и объяснить результат:

    ```jsx
    handleChange = () => {
        console.log(this.state.checked) //#1 false
        this.setState({
          checked: !this.state.checked, //true
        });
        console.log(this.state.checked) //#2 false
      };
    ```

setState работает асинхронно, поэтому выполнится лог номер 1 - выведет false, потом изменение состояния поставится в очередь, но еще не изменится, потом выполнится лог номер 2 - выведет false, потом изменится состояние из очереди.

6. Какими способами можно задать функцию `handleChange` и какой из них является самым правильным?
Стрелочная функция, через конструктор или методом bind
Правильнее всего делать это через стрелочные функции, так как они компактны, сохраняют контекст и не требуют явной привязки в конструкторе или внутри render()

7. Чем отличаются классовые и функциональные компоненты? Какие из них предпочтительнее в 2021 году?
Классовые компоненты:
Синтаксис: Определены с использованием синтаксиса ES6 классов.
State: Могут иметь состояние (state) и жизненный цикл (lifecycle methods), такие как componentDidMount, componentDidUpdate, componentWillUnmount, и другие.
Привязка контекста: Методы требуют явной привязки контекста (this) внутри конструктора или с помощью стрелочной функции.
Читаемость кода: Возможно создание более крупных и сложных компонентов с внутренним состоянием и логикой.
Функциональные компоненты:

Синтаксис: Определены как обычные функции JavaScript и до появления хуков не имели состояния и методов жизненного цикла.
Хуки: С появлением хуков, функциональные компоненты получили возможность использовать состояние, эффекты и другие возможности, которые ранее были доступны только классовым компонентам.
Чистота: Функциональные компоненты обычно считаются более чистыми и имеют меньше "шума" в коде из-за отсутствия наследования и использования this.
Краткость: Обычно более компактны и менее громоздкие по сравнению с классовыми компонентами.
функциональные компоненты с хуками более предпочтительными в разработке React

8. Есть ли `this` в функциональных компонентах? Как можно получить доступ к нему?
В функциональных компонентах в React нет this. this связан с контекстом выполнения, который относится к объекту, внутри которого функция была вызвана или создана. В классовых компонентах React this используется для доступа к состоянию (state) компонента, методам жизненного цикла и другим членам класса.
Однако, в функциональных компонентах с использованием хуков, таких как useState, useEffect и других, можно получить доступ к функциональному эквиваленту this, который называется "замыканием" или захватом состояния

9. Можно ли использовать `props` и `state` одновременно?
Да, в React компоненте можно использовать и props, и state одновременно.

10. Где можно задать `state` без использования команды `this.setState`?
определять и использовать состояние без использования this.setState можно путем использования useState.

11. Может ли состояние классового компонента не быть объектом? А функционального?
В React состояние классового компонента обязательно должно быть объектом. Это ограничение связано с тем, что this.state в классовых компонентах React предполагает использование объекта для хранения данных.
В функциональных компонентах React, использующих хуки (например, useState), состояние также может быть представлено не только объектом, но и другими типами данных, такими как примитивы (числа, строки, булевы значения), массивы и т.д. Если необходимо хранить несколько значений в функциональном компоненте, можно использовать несколько useState или хранить их внутри объекта.

12. Способны ли функциональные компоненты самостоятельно хранить состояние?
не способны без использования хуков, так что если считать хук частью ФК - то ответ "да", а если считать хук отдельной функцией - ответ "нет"

13. Как использовать хуки в классовых компонентах?
Хуки предназначены для использования исключительно в функциональных компонентах в React.
Однако, в документации по реакту указано следующее:
"Вы не можете использовать хуки внутри классового компонента, но вы можете комбинировать классы и функциональные компоненты с хуками в одном дереве. Является ли компонент классовым или функциональным с использованием хуков — неважно, это всего лишь особенность реализации. Мы ожидаем, что в будущем хуки станут главным способом написания React-компонентов."

14. А как задать начальное состояние `props`, если они ещё не были переданы?
нужно использовать значение по умолчанию или условную проверку

function MyComponent(props) {
  const [value, setValue] = useState(props.initialValue || 'Default Value');

function MyComponent(props) {
  const [value, setValue] = useState(
    props.initialValue ? props.initialValue : 'Default Value'
  );
